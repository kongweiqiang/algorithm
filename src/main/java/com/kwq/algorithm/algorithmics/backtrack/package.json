{
  "name": "backtrack",
  "zh": "回溯",
  "description": [
    {"解决问题":[
      "组合问题：N个数里面按一定规则找出k个数的集合",
      "排列问题：N个数按一定规则全排列，有几种排列方式",
      "切割问题：一个字符串按一定规则有几种切割方式",
      "子集问题：一个N个数的集合里有多少符合条件的子集",
      "棋盘问题：N皇后，解数独等等"]
    },
    {"回溯三部曲":[
      "回溯算法中函数返回值一般为void",
      "回溯函数终止条件:以树看待,遇到叶子节点,保存结果,return"]
    },
    {"回溯要点":[
      "回溯法解决的问题都可以抽象为树形结构",
      "集合的大小就构成了树的宽度，递归的深度，都构成的树的深度",
      "for循环横向遍历，递归纵向遍历，回溯不断调整结果集,用递归控制for循环嵌套的数量"]
    },
    {"剪枝精髓":[
    "for循环在寻找起点的时候要有一个范围，如果这个起点到集合终止之间的元素已经不足题目要求的k个元素了,代表本次不会有结果产生，就没有必要搜索了",
    "for循环在寻找起点的时候要有一个范围，如果这个起点到集合终止之间的元素已经达到题目要求的k个元素了,代表本次已经达标，就没有必要继续搜索了"]
    }
  ]
}
/** 回溯模板
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }
    //单层逻辑
    for (选择：本层集合中元素(树中节点孩子的数量就是集合的大小)) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
*/
/**
   去重模板
      // boolean used[i - 1] == true， 说明同一树支candidates[i - 1]使用过同一个元素值
      // boolean used[i - 1] == false，说明同一树层candidates[i - 1]使用过同一个元素值
*/
